---
title: "The Billing Edge Case Checklist"
description: "A comprehensive checklist of billing edge cases that destroy revenue if not handled properly in production."
date: "2025-02-08"
author: "Ai.Rio"
category: "Billing Operations"
tags: ["billing", "edge-cases", "stripe", "production", "checklist"]
---

# The Billing Edge Case Checklist

Your billing works for 99% of customers. The 1% edge cases are costing you 20% of your revenue. Failed payments, proration errors, upgrade/downgrade bugs—they're all silently bleeding revenue.

Here's the checklist.

## The Problem

Billing edge cases are tricky because:
- They're rare (1-5% of transactions)
- They're expensive (high-value customers)
- They're silent (customers don't report them)
- They compound (affects future bills)

Industry data:
- **15%** of revenue lost to unhandled edge cases
- **40%** of customers experience at least one billing issue annually
- **60%** of customers won't give you a second chance

## The Checklist

### 1. Payment Failures

#### 1.1 Insufficient Funds
```typescript
// BAD: Just retry immediately
if (error.code === 'insufficient_funds') {
  await retryPayment(invoiceId);
}

// GOOD: Smart retry schedule
const retrySchedule = {
  'insufficient_funds': [2, 5, 9, 14], // Days to wait
  'expired_card': [1, 3, 7],
  'generic_decline': [3, 7, 14],
};

await scheduleRetry(invoiceId, retrySchedule[error.code]);
```

#### 1.2 Card Expired Mid-Cycle
```typescript
// Detect upcoming expirations
async function checkExpiringCards() {
  const nextMonth = new Date();
  nextMonth.setMonth(nextMonth.getMonth() + 1);

  const customers = await stripe.customers.list({
    limit: 100,
    expand: ['data.sources'],
  });

  for (const customer of customers.data) {
    const card = customer.default_source as any;
    if (card && card.exp_year === nextMonth.getFullYear() &&
        card.exp_month === nextMonth.getMonth() + 1) {
      await sendCardExpiringNotification(customer.id, card.last4);
    }
  }
}
```

#### 1.3 Bank Declines (High Risk)
```typescript
// High-value customers need special handling
async function handleHighRiskDecline(customerId: string, invoiceId: string) {
  const customer = await getCustomerValue(customerId);

  if (customer.mrr > 500) {
    // Flag for manual review
    await flagForReview({
      customerId,
      invoiceId,
      reason: 'high_risk_decline',
      priority: 'high',
      action: 'personal_outreach',
    });
  } else {
    // Standard dunning flow
    await sendDunningEmail(customerId, invoiceId);
  }
}
```

### 2. Proration Edge Cases

#### 2.1 Upgrade Mid-Cycle
```typescript
// When upgrading, credit unused time
async function handleUpgrade(
  subscriptionId: string,
  newPriceId: string
) {
  const subscription = await stripe.subscriptions.retrieve(subscriptionId);
  const currentPeriodEnd = subscription.current_period_end;

  // Calculate remaining time
  const now = Math.floor(Date.now() / 1000);
  const remainingSeconds = currentPeriodEnd - now;
  const remainingRatio = remainingSeconds / subscription.items.data[0].plan.interval_count;

  // Calculate credit for unused time
  const currentPrice = subscription.items.data[0].price.unit_amount!;
  const credit = Math.floor(currentPrice * remainingRatio);

  // Apply credit to new plan
  await stripe.subscriptions.update(subscriptionId, {
    items: [{
      id: subscription.items.data[0].id,
      price: newPriceId,
    }],
    proration_behavior: 'always_invoice',
    promotion_code: await createCredit(credit),
  });
}
```

#### 2.2 Downgrade with Annual Plan
```typescript
// Annual to downgrade needs special handling
async function handleAnnualDowngrade(
  subscriptionId: string,
  newPriceId: string
) {
  const subscription = await stripe.subscriptions.retrieve(subscriptionId);

  if (subscription.items.data[0].recurring.interval === 'year') {
    // Don't prorate immediately
    // Schedule change for next renewal
    await stripe.subscriptions.update(subscriptionId, {
      items: [{
        id: subscription.items.data[0].id,
        price: newPriceId,
      }],
      proration_behavior: 'none',
    });

    await sendDowngradeConfirmation(subscription.customer as string, {
      effectiveDate: subscription.current_period_end,
      newPlan: newPriceId,
    });
  }
}
```

#### 2.3 Multiple Changes in Same Cycle
```typescript
// Prevent multiple prorations
async function updateSubscription(
  subscriptionId: string,
  updates: SubscriptionUpdate[]
) {
  // Check for pending updates
  const subscription = await stripe.subscriptions.retrieve(subscriptionId);
  const hasPendingUpdate = subscription.pending_update !== null;

  if (hasPendingUpdate) {
    throw new Error('Cannot update: pending update already in progress');
  }

  // Batch all changes
  return await stripe.subscriptions.update(subscriptionId, {
    items: updates.map(u => ({
      id: subscription.items.data[0].id,
      price: u.priceId,
      quantity: u.quantity,
    })),
    proration_behavior: 'always_invoice',
  });
}
```

### 3. Subscription State Transitions

#### 3.1 Cancel → Reactivate
```typescript
// Handle reactivation with same plan
async function reactivateSubscription(subscriptionId: string) {
  const subscription = await stripe.subscriptions.retrieve(subscriptionId);

  if (subscription.status === 'canceled') {
    // Create new subscription
    const newSubscription = await stripe.subscriptions.create({
      customer: subscription.customer as string,
      items: subscription.items.data.map(item => ({
        price: item.price.id,
        quantity: item.quantity,
      })),
      coupon: 'welcome_back', // Optional incentive
    });

    return newSubscription;
  }

  // Resume paused subscription
  return await stripe.subscriptions.update(subscriptionId, {
    pause_collection: null as any,
  });
}
```

#### 3.2 Trial → Paid Transition
```typescript
// Ensure payment method is valid before trial ends
async function validateTrialPaymentMethod(subscriptionId: string) {
  const subscription = await stripe.subscriptions.retrieve(subscriptionId);
  const customer = await stripe.customers.retrieve(
    subscription.customer as string
  );

  if (!customer.invoice_settings.default_payment_method) {
    // Send reminder to add payment method
    await sendPaymentMethodReminder(customer.id);

    // Optionally pause subscription
    const daysUntilTrialEnd = Math.floor(
      (subscription.trial_end! - Date.now() / 1000) / 86400
    );

    if (daysUntilTrialEnd <= 3) {
      await stripe.subscriptions.update(subscriptionId, {
        trial_settings: {
          end_behavior: {
            missing_payment_method: 'cancel',
          },
        },
      });
    }
  }
}
```

#### 3.3 Pause → Resume
```typescript
// Handle paused subscriptions correctly
async function resumePausedSubscription(subscriptionId: string) {
  const subscription = await stripe.subscriptions.retrieve(subscriptionId);

  if (subscription.pause_collection) {
    await stripe.subscriptions.update(subscriptionId, {
      pause_collection: null as any,
      billing_cycle_anchor: 'now', // Charge immediately
      proration_behavior: 'create_prorations',
    });
  }
}
```

### 4. Tax Edge Cases

#### 4.1 Tax Exempt Customers
```typescript
// Handle tax exemption correctly
async function applyTaxExemption(customerId: string, taxId: string) {
  // Validate tax ID
  const validation = await validateTaxId(taxId);
  if (!validation.valid) {
    throw new Error('Invalid tax ID');
  }

  // Update customer
  await stripe.customers.update(customerId, {
    tax_ids: [{ type: 'eu_vat', value: taxId }],
    tax_exempt: 'exempt',
  });

  // Recalculate existing subscriptions
  const subscriptions = await stripe.subscriptions.list({
    customer: customerId,
    status: 'active',
  });

  for (const subscription of subscriptions.data) {
    await stripe.subscriptions.update(subscription.id, {
      default_tax_rates: [],
    });
  }
}
```

#### 4.2 Cross-Border Tax
```typescript
// Handle location-based tax correctly
async function calculateTax(customerId: string, amount: number) {
  const customer = await stripe.customers.retrieve(customerId);
  const address = customer.address;

  if (!address) {
    // Use IP-based location
    const location = await getIPLocation(customer.ip!);
    return await calculateTaxForLocation(location, amount);
  }

  return await calculateTaxForLocation(address, amount);
}
```

### 5. Discount & Coupon Edge Cases

#### 5.1 Stacking Coupons
```typescript
// Prevent coupon stacking unless intentional
async function applyCoupon(subscriptionId: string, couponId: string) {
  const subscription = await stripe.subscriptions.retrieve(subscriptionId);

  // Check for existing discount
  if (subscription.discount) {
    throw new Error('Cannot stack coupons');
  }

  return await stripe.subscriptions.update(subscriptionId, {
    coupon: couponId,
  });
}
```

#### 5.2 Expired Coupons
```typescript
// Validate coupon before applying
async function applyCouponValidated(subscriptionId: string, couponId: string) {
  const coupon = await stripe.coupons.retrieve(couponId);

  if (!coupon.valid) {
    throw new Error('Coupon is no longer valid');
  }

  if (coupon.max_redemptions && coupon.times_redeemed >= coupon.max_redemptions) {
    throw new Error('Coupon redemption limit reached');
  }

  if (coupon.redeem_by && coupon.redeem_by < Date.now() / 1000) {
    throw new Error('Coupon has expired');
  }

  return await stripe.subscriptions.update(subscriptionId, {
    coupon: couponId,
  });
}
```

### 6. Invoice Edge Cases

#### 6.1 Invoice Too Large
```typescript
// Handle invoices that exceed Stripe limits
async function handleLargeInvoice(customerId: string, lineItems: LineItem[]) {
  const MAX_AMOUNT = 99999999; // Stripe's max

  // Split into multiple invoices
  const chunks = chunkArray(lineItems, 100);
  const invoices = [];

  for (const chunk of chunks) {
    const invoice = await stripe.invoices.create({
      customer: customerId,
      lines: chunk.map(item => ({
        quantity: item.quantity,
        price_data: {
          currency: 'usd',
          product_data: { name: item.description },
          unit_amount: item.amount,
        },
      })),
    });

    await stripe.invoices.pay(invoice.id);
    invoices.push(invoice);
  }

  return invoices;
}
```

#### 6.2 Zero-Dollar Invoice
```typescript
// Skip zero-dollar invoices
async function finalizeInvoice(invoiceId: string) {
  const invoice = await stripe.invoices.retrieve(invoiceId);

  if (invoice.total === 0) {
    // Mark as paid without attempting payment
    await stripe.invoices.pay(invoiceId, {
      paid_out_of_band: true,
    });
  } else {
    // Normal finalize
    await stripe.invoices.finalizeInvoice(invoiceId);
  }
}
```

### 7. Webhook Edge Cases

#### 7.1 Duplicate Webhooks
```typescript
// Handle duplicate webhook events
async function handleWebhook(event: Stripe.Event) {
  // Check if already processed
  const processed = await db.webhookEvents.findUnique({
    where: { id: event.id },
  });

  if (processed) {
    return { status: 'duplicate' };
  }

  // Process event
  await processEvent(event);

  // Mark as processed
  await db.webhookEvents.create({
    data: {
      id: event.id,
      type: event.type,
      processedAt: new Date(),
    },
  });
}
```

#### 7.2 Out-of-Order Webhooks
```typescript
// Handle webhooks arriving out of order
async function handleWebhookOrdered(event: Stripe.Event) {
  const sequence = await getEventSequence(event.data.object.id);

  // Check if we're missing events
  if (sequence.lastProcessed + 1 !== event.created) {
    // Buffer this event
    await bufferEvent(event);

    // Try to process missing events
    await processBufferedEvents(event.data.object.id);
  } else {
    // Process normally
    await processEvent(event);
  }
}
```

### 8. Migration Edge Cases

#### 8.1 Migrating from Other Systems
```typescript
// Migrate customers without service interruption
async function migrateCustomer(
  legacyCustomerId: string,
  stripeCustomerId: string
) {
  // Get current billing state from legacy system
  const legacyData = await legacy.getCustomer(legacyCustomerId);

  // Create matching subscription in Stripe
  const subscription = await stripe.subscriptions.create({
    customer: stripeCustomerId,
    items: [{
      price: mapLegacyPlanToStripe(legacyData.plan),
      quantity: legacyData.quantity,
    }],
    trial_period_days: legacyData.daysRemaining,
    billing_cycle_anchor: legacyData.nextBillingDate,
  });

  // Update legacy system
  await legacy.markMigrated(legacyCustomerId, subscription.id);

  return subscription;
}
```

## Testing Checklist

Before deploying billing changes:

- [ ] Test payment failure scenarios
- [ ] Test upgrade/downgrade flows
- [ ] Test coupon application and expiration
- [ ] Test tax calculation for different regions
- [ ] Test webhook delivery and replay
- [ ] Test proration calculations
- [ ] Test subscription state transitions
- [ ] Test invoice generation and finalization
- [ ] Test refund processing
- [ ] Test migration from legacy systems

## Monitoring

```typescript
// Set up alerts for edge cases
async function setupEdgeCaseAlerts() {
  // Payment failure rate > 5%
  await createAlert({
    name: 'high_payment_failure_rate',
    condition: 'payment_failure_rate > 0.05',
    action: 'notify_team',
  });

  // Proration discrepancy > $10
  await createAlert({
    name: 'proration_discrepancy',
    condition: 'proration_difference > 10',
    action: 'flag_for_review',
  });

  // Invoice generation failure
  await createAlert({
    name: 'invoice_generation_failure',
    condition: 'invoice_failed = true',
    action: 'immediate_notification',
  });
}
```

## The Bottom Line

Billing edge cases are where revenue lives or dies. The 1% edge cases cost you 20% revenue.

**Key takeaways:**
1. Test every edge case in staging
2. Monitor for edge case patterns in production
3. Build automated remediation where possible
4. Manual review for high-value customers
5. Keep a runbook of common edge cases

Your billing should handle the 1% as gracefully as the 99%.

---

**Want to see how Ai.Rio can help you build billing infrastructure that handles all edge cases automatically?** Your margins are a black box. Ai.Rio built a flashlight.
