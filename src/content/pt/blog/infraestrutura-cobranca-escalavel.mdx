---
title: "Construa Infraestrutura de Cobrança que Escale"
description: "Padrões arquiteturais para construir infraestrutura de cobrança que lida com milhões em receita sem quebrar."
date: "2025-02-08"
author: "AI.RIO"
category: "Infraestrutura"
tags: ["infraestrutura", "escalabilidade", "stripe", "arquitetura", "cobranca"]
---

# Construa Infraestrutura de Cobrança que Escale

Seu SaaS de IA está crescendo. $25K MRR hoje, $250K MRR amanhã. Sua infraestrutura de cobrança precisa lidar com o crescimento sem reescrever tudo.

Aqui está como construir infraestrutura de cobrança que escala.

## O Problema

A maioria da infraestrutura de cobrança começa simples:

```typescript
// Cobrança rápida e suja
async function chargeCustomer(customerId: string, amount: number) {
  const customer = await db.customers.findUnique({ where: { id: customerId } });
  await stripe.paymentIntents.create({
    amount: amount * 100,
    currency: 'usd',
    customer: customer.stripeId,
  });
}
```

Isso funciona a $25K MRR. Quebra a $250K MRR quando:
- Webhooks chegam fora de ordem
- Retries de pagamento criam condições de corrida
- Consultas de relatórios levam minutos
- Reembolsos requerem trabalho manual em planilhas
- Cálculos de prorrateo são inconsistentes

## A Solução

Construa infraestrutura de cobrança em torno destes princípios:
1. **Idempotência**: Cada operação é segura para retry
2. **Event sourcing**: Rastro de auditoria para cada evento de cobrança
3. **Processamento assíncrono**: Webhooks não bloqueiam
4. **Réplicas de leitura**: Relatórios não impactam transações
5. **Circuit breakers**: Falhas de terceiros não se propagam

### Visão Geral da Arquitetura

```
┌─────────────────────────────────────────────────────────┐
│                  Sua Aplicação                          │
└───────────────────────┬─────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────┐
│              Camada de Serviço de Cobrança              │
│  ┌─────────────┐  ┌─────────────┐  ┌──────────────┐   │
│  │Subscription │  │   Invoice   │  │   Payment    │   │
│  │  Service    │  │   Service   │  │   Service    │   │
│  └──────┬──────┘  └──────┬──────┘  └──────┬───────┘   │
└─────────┼────────────────┼────────────────┼─────────────┘
          │                │                │
          ▼                ▼                ▼
┌─────────────────────────────────────────────────────────┐
│              Barramento de Eventos (Fila)               │
└───────────────────────┬─────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────┐
│              Handlers de Eventos (Workers)              │
│  ┌─────────────┐  ┌─────────────┐  ┌──────────────┐   │
│  │   Webhook   │  │   Relatório │  │ Notificação  │   │
│  │  Processor  │  │  Aggregator │  │   Service    │   │
│  └─────────────┘  └─────────────┘  └──────────────┘   │
└───────────────────────┬─────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────┐
│              Camada de Dados                            │
│  ┌─────────────┐  ┌─────────────┐  ┌──────────────┐   │
│  │ DB Primário │  │ Réplica Leitura│ Event Store  │   │
│  │(Transacional)│  │ (Relatório) │  │  (Auditoria) │   │
│  └─────────────┘  └─────────────┘  └──────────────┘   │
└─────────────────────────────────────────────────────────┘
```

## Implementação

### 1. Operações Idempotentes

```typescript
// lib/billing/idempotency.ts
export class IdempotentOperation {
  async execute<T>(
    key: string,
    fn: () => Promise<T>,
    options: { ttl?: number } = {}
  ): Promise<T> {
    // Verificar se já foi executado
    const existing = await db.idempotencyKeys.findUnique({
      where: { key },
    });

    if (existing) {
      if (existing.status === 'completed') {
        return JSON.parse(existing.response) as T;
      }
    }

    // Marcar como processando
    await db.idempotencyKeys.upsert({
      where: { key },
      create: { key, status: 'processing' },
      update: { status: 'processing' },
    });

    try {
      const result = await fn();
      await db.idempotencyKeys.update({
        where: { key },
        data: {
          status: 'completed',
          response: JSON.stringify(result),
        },
      });
      return result;
    } catch (error) {
      await db.idempotencyKeys.update({
        where: { key },
        data: { status: 'failed' },
      });
      throw error;
    }
  }
}
```

## Lista de Verificação de Escalabilidade

- [ ] Todas as operações são idempotentes
- [ ] Webhooks são processados assincronamente
- [ ] Eventos são armazenados para rastro de auditoria
- [ ] Réplicas de leitura para consultas de relatórios
- [ ] Circuit breakers para APIs externas
- [ ] Degradação elegante para falhas
- [ ] Monitoramento e alertas abrangentes
- [ ] Testes automatizados de failover
- [ ] Pool de conexões de banco de dados
- [ ] Otimização de consultas e indexação
- [ ] Estratégia de cache para operações caras
- [ ] Rate limiting para endpoints API

## Conclusão

Construir infraestrutura de cobrança que escala não é sobre lidar com mais tráfego. É sobre lidar com complexidade mantendo confiabilidade.

**Pontos principais:**
1. Design para idempotência desde o primeiro dia
2. Event sourcing dá rastro de auditoria
3. Processamento assíncrono previne gargalos
4. Réplicas de leitura mantêm relatórios rápidos
5. Circuit breakers previnem falhas em cascata

Sua infraestrutura de cobrança deve ser chata. Confiável. Previsível. Seus clientes não deveriam pensar nela.

---

**Quer ver como a AI.RIO pode ajudá-lo a construir infraestrutura de cobrança que escala de $25K para $250K MRR?** Suas margens são uma caixa preta. Construí uma lanterna.
